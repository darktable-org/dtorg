title: darktable 2.6
lang: fr
author: Nilvus (traduction de l'article écrit par moy)
date: 2018-12-24
lede: butterfly.jpg
lede_author: 
tags: annonce, darktable-release

WARNING: Ceci est un brouillon qui ne doit pas être édité.
WARNING: L'édition de la traduction française se fait sur
WARNING: https://linuxfr.org/redaction/news/darktable-2-6

TODO: intro.

Parmi les principales nouveautés :

* Un nouveau module « retouche », similaire au module de « correction de tâches », avec copie intelligente (« outil de correction ») et la possibilité d'agir sur chaque niveau de détail individuellement.

* Un nouveau module « filmique », capable de gérer la plupart des aspects de tonalité d'une image en un seul module.

* Une refonte complète du module de « balance des couleurs », qui peut désormais être
  seen as a color-aware variant of "levels", et permet la plupart des ajustements automatiquement grâce à de nouvelles options de sélection de couleurs.

* La possibilité de guider le floutage du masque de fusion, afin de sélectionner précisément un objet avec le minimum d'effort.

# Fonctionnalités principales

## Un nouveau module : _retouche_

Alors que darktable se focalise principalement sur le développement raw, les dernières versions ont introduit des fonctionnalités habituellement réservées aux éditeurs orientés pixels tel que GIMP, comme le module _liquéfier_. 
Une étape importante de plus dans cette direction est faite avec ce nouveau module _retouche_, qui remplace essentiellement le module _correction des tâches_, avec séparation des fréquences pour une retouche fine.

### Améliorations comparées au module _correction des tâches_

Le module a bien plus d'options que le module _correction des tâches_, mais tout ce que vous pouviez faire avec le précédent reste disponible dans le module _retouche_.

![Aperçu du module retouche](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-overview-fr.png)

Comme avec _correction des tâches_, vous sélectionnez une forme (cercle, ellipse, chemin, ou brosse ; cette dernière n'existait pas dans _correction des tâches_) et vous cliquez simplement sur la partie de l'image que vous souhaitez effacer. Le module va copier une autre partie de l'image pour la masquer. Glissez au lieu de cliquer pour choisir la source à cloner, ou ajustez les contrôles ensuite.

De nombreux détails vont vous faciliter la vie :

#### Outil de correction, de meilleurs résultats en moins d'efforts

Par défaut, la copie utilise un algorithme de correction (*heal* en anglais) emprunté de l'outil correcteur de GIMP, qui adapte la source au contexte de l'emplacement copié. Vous n'avez pas besoin de copier exactement la bonne partie de l'image. Prenons un exemple classique, un petit défaut dans un ciel pas complètement uniforme :

![Exemple de retouche](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-original.png)

Une mauvaise tentative pour corriger cela avec l'outil de copie donnerait :

![Retouche par copie (avec contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone.png)

Le morceau de ciel copié pour masquer le défaut est un peu plus sombre que l'endroit où il a été copié. Ce n'est pas évident tant que les outils de contrôle sont affichés sur l'image, mais l'image finale est vraiment mauvaise :

![Retouche par copie (sans contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone-nocontrol.png)

La même retouche  avec le nouvel `outil de correction` (![outil de correction](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal-icon.png)) donne ceci :
 
![Retouche de correction (avec contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal.png)

Cette fois, l'image finale est indistinguable d'un ciel sans défaut :

![Retouche de correction (sans contrôles)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal-nocontrol.png)

Même en clonant des parties de l'image de couleurs complètement différentes, l'`outil de correction` réagit étonnamment bien. Poussons le module un peu :

![Retouche de correction sur des couleurs différentes](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-heal-red-white-blue.png)

Le morceau blanc est copié vers le t-shirt bleu, le t-shirt bleu vers le rouge, et le rouge vers le blanc. Chaque fois, le contraste local est conservé, mais la couleur générale et la luminance du morceau sont adaptés pour s'ajuster à la destination.

L'`outil de copie` basique (![outil de copie](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone-icon.png)) est toujours disponible pour les rares situations où vous en auriez besoin.

#### Remplir et flouter, quand vous n'avez rien à copier

En plus des outils de copie et de correction (qui fonctionnent seulement quand vous avez une partie de l'image à dupliquer sur celle à effacer), le module _retouche_ fournit un `outil de remplissage` (![outil de remplissage](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-fill-icon.png)) (remplir une forme avec une couleur) et un `outil de flou` (![outil de flou](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-blur-icon.png)) (appliquer un flou pour adoucir une partie de l'image). Ces outils sont particulièrement utiles pour l'édition par séparation de fréquence (voir plus bas).

#### Une activation, plusieurs corrections : ajout continu

Les outils peuvent être activés en une fois pour plusieurs corrections. Utilisez simplement la combinaison `Ctrl`-`clic` sur l'un des outils cercle, ligne, ellipse ou chemin (au lieu d'un simple clic), et l'outil restera actif jusqu'à ce que vous le désactiviez explicitement.
Ceci est très pratique lorsque vous avez à corriger plusieurs endroits de la même image, comparé au précédent flux de travail qui vous obligeait à cliquer sur le bouton de l'outil pour chaque correction.

#### Visualisation de la source de correction

Pour les outils de copie et de correction, chaque correction consiste à sélectionner une source et une destination. Un simple clic permet de définir la destination et, par défaut, darktable sélectionne une zone arbitraire pour la source. Une autre option est de définir la source et la destination par un glisser-déposer avec le curseur de la destination vers la source.

_retouche_ introduit un mécanisme plus avancé :

* En déplaçant le curseur sur l'image, la destination à corriger est marquée par une forme, alors que la source est marquée par une petite croix :

![Source & destination de retouche](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-source-cross.png)

* Pour sélectionner une source, utiliser `Maj`-`clic` sur l'image. La croix est alors placée sur l'emplacement du curseur et ne bougera plus jusqu'à ce que vous sélectionnez la destination, via un simple clic. Ceci est particulièrement intéressant combiné à une activation permanente de l'outil mentionné ci-dessus : plusieurs corrections sont ainsi possibles sur l'image, la source restant à des coordonnées relatives à la destination.

* Une variante : utiliser `Ctrl`-`Maj`-`Clic` au-lieu de `Maj`-`Clic`. Ceci définira également l'emplacement de la source, mais cette fois, celle-ci restera fixe, selon des coordonnées absolues et non plus relatives à la destination à corriger.

### Édition par séparation de fréquence

Une difficulté classique de la retouche photo, typiquement pour le portrait, est de souhaiter masquer certaines tâches, et parfois réduire le contraste local afin de rendre la peau plus lisse, tout en conservant sa texture. Un effacement brutal rendrait la peau trop lisse et donnera à la photo, au mieux, un aspect « excessivement post-traité ».

Prenons une image comme exemple (reprise du [défi pixls.us PlayRaw](https://discuss.pixls.us/t/playraw-hillbilly-portrait/5518)) :

![Exemple de portrait](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-overall-portrait.jpg)

Une technique commune pour ce type de retouche est de séparer l'image en plusieurs images correspondant à plusieurs niveaux de détails, et de les combiner ensemble. C'est ce que permet le [greffon _Décomposer en ondelettes_ de GIMP (article en anglais)](https://pixls.us/articles/skin-retouching-with-wavelet-decompose/) par exemple.

Après séparation, cela produit une première image trouble aux détails grossiers, et une ou plusieurs images contenant seulement les détails.

Dans notre exemple, nous obtenons :

![Exemple de portrait](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale4.jpg)

![Exemple de portrait, échelle 5](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale5.jpg)

![Exemple de portrait, échelle 6](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale6.jpg)
 
![Exemple de portrait, échelle 7](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-portrait-scale7.jpg)

Ce type de transformation est utilisé en interne par le module _égaliseur_, qui permet d'augmenter ou diminuer l'importance de chaque niveau de détails de l'image. Alors que _égaliseur_ travaille globalement sur l'image, _retouche_ permet de sélectionner le niveau de détails et la partie de l'image sur laquelle vous souhaitez travailler.

Dans le module _retouche_, cela correspond à la partie _décomposition en ondelettes_ de l'interface :

![Échelles de décomposition en ondelettes](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-scales-fr.png)

Cette partie montre un rectangle par échelle de décomposition (du grain le plus fin à gauche au grain le plus grossier à droite). Le rectangle noir à gauche corresponds à l'image entière, et le blanc à droite à l'image résiduelle, c'est-à-dire l'image où tous les autres niveaux de détails ont été enlevés. Par défaut, darktable montre toujours l'image finale, mais vous pouvez visualiser une échelle de détails et l'image résiduelle en cliquant sur le bouton `affiche une seule échelle de décomposition` (![affiche une seule échelle de décomposition](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-display-wavelet-scales.png)).

L'image actuellement sélectionnée apparaît avec un rectangle rouge. Déplacez le curseur du bas pour modifier le nombre d'échelles de détails à utiliser. Selon le niveau de zoom, certains détails d'échelle peuvent être plus fins que le permet la résolution de l'écran, donc inutilisables. La ligne grise sur le dessus des échelles montre lesquelles sont visibles au niveau de zoom actuel.

En visualisant l'échelle de détails, le contraste peut être trop faible ou trop fort,  le module propose donc un ajustement de niveaux (qui s'applique seulement sur la prévisualisation à l'écran, et non sur l'image finale) :

![Niveaux d'ajustement](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-levels-fr.png)

Chaque type d'outil présenté ci-dessus (`outil de correction`, `outil de copie`, `outil de remplissage` ou `outil de flou`) est utilisable sur chacune de ces échelles. Pensez-y comme à des calques obtenus d'une image source, et recomposés ensemble, après retouche, afin d'obtenir l'image finale. C'est là où les outils de `remplissage` et de `flou` prennent le plus de sens : `outil de remplissage` est par défaut un mode d'effacement lorsque la couleur choisie est le noir, ce qui correspond à supprimer les détails lorsqu'il est utilisé sur les échelles de détails. Il est aussi possible de sélectionner une couleur et de remplir avec celle-ci (particulièrement utile sur l'échelle de l'image résiduelle). Utiliser l'`outil de flou` directement sur l'image, aboutit à des résultats de post-traitement clairement visibles, mais l'utiliser de manière sélective sur les échelles permet d'aboutir à des effets plus subtils.

#### Exemple 1: réduction de tâche au lieu de suppression

Concentrons-nous sur le bouton situé sous la branche des lunettes. Si nous souhaitons le supprimer complètement, il est facile de le faire avec l'`outil de correction`. Maintenant, que se passe-t-il si nous souhaitons le conserver, et seulement le réduire, pour qu'il n'attire plus l'attention ? Nous pouvons simplement le supprimer depuis l'échelle de détails grossiers (échelle 6 dans notre exemple).
Le bouton n'est alors plus visible sur l'image résiduelle, le supprimer depuis l'échelle de détails est donc suffisant. L'`outil de correction` permet de le faire proprement. Mais en agissant avec l'échelle de détails, l'`outil de remplissage` et l'`outil de flou` peuvent aussi donner de bons résultats. Voici ci-dessous le résultat sur l'échelle 6 (avant à gauche, après à droite).

![Avant/après à l'échelle 6](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-before-after-scale6.jpg)

L'image finale sera transformée comme suit :

![Avant/après à l'échelle  6 (image finale)](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-before-after-final.jpg)

Désormais, nous pouvons décider que la correction faite sur l'échelle 6 peut aussi s'appliquer à l'échelle 5. Nous pouvons faire la même chose manuellement, mais nous pouvons également utiliser le curseur du haut, intitulé `début de fusion`, afin de reproduire automatiquement les formes corrigées sur plusieurs échelles. Toute forme créée à droite de ce curseur sera reproduite sur toutes les échelles au delà de ce curseur de fusion (excepté si le curseur est positionné complètement à gauche (à 0), ce qui signifie que la fusion est désactivée).

Par exemple, en positionnant le curseur à 5, nous appliquons la correction sur les échelles 5 et 6, et obtenons ceci :

![Avant/après à l'échelle 6](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-merge-5-6.jpg)

Si nous déplaçons le curseur plus à gauche, le bouton disparaît progressivement. Selon ce même principe, nous pouvons effacer les marques sur la peau tout en préservant les poils de la barbe :

![Avant/après, en préservant la barbe](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-beard-preserve.jpg)

(Juste une correction sur l'échelle 7, propagée ensuite jusqu'à l'échelle 5 en utilisant le curseur de fusion)

#### Exemple 2 : jouer avec la texture de peau

Si vous voulez changer la texture de peau sur la joue, vous pouvez appliquer un flou sur une forme de ce type :

![Flou sur une échelle de détail](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-blur-detail.jpg)

et obtenez le résultat avant/après suivant :

![En changeant la texture de peau](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-skin-texture.jpg)

De toute évidence, ce type de retouche doit être pratiqué avec une grande prudence : si la correction est poussée trop loin, cela produira un rendu trop artificiel.

En cas de doute, vous pouvez toujours revenir en arrière sur votre retouche et utiliser un mode de fusion avec une opacité inférieure à 100%, ou modifier l'opacité ou le rayon de flou de chaque forme individuellement.

#### Exemple 3 : s'amuser avec l'image résiduelle

Juste pour le plaisir (ne reproduisez pas ça chez vous, ou attendez-vous à des images horribles !), nous pouvons obtenir un effet « tatouage » en utilisant l'`outil de copie` sur l'image résiduelle :

![Copie sur l'image résiduelle](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/rt-clone-residual-image.jpg)

Bien que peu élégant, cet exemple illustre le principe de «  séparation de fréquence  » : nous avons conservé les détails fins de la joue, et copié des détails grossiers de l'image résiduelle.

## Nouveau module : _filmique_

Le module _filmique_ a été conçu pour reproduire les meilleurs aspects d'un film analogique associés aux contrôles plus aisés de la photographie digitale. Il peut être utilisé sur toute image en remplacement du module _courbe de base_, et est particulièrement adapté pour les images à grande plage dynamique (high dynamic range - HDR), c'est-à-dire une différence importante entre les zones les plus clairs et les plus sombres de l'image.

Prenons un exemple d'une telle image :

![Exemple d'image HDR](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-example-image.jpg)

Une approche commune pour agir avec des images à plage dynamique étendue (HDR) est de comprimer le contraste global tout en conservant le contraste local. darktable a plusieurs modules capable de faire cela : _mappage tonalités_, _mappage global tonalités_, _ombres et hautes lumières_, et depuis darktable 2.2 le mode de `fusion d'exposition` dans le module _courbe de base_. Cette compression de contraste fonctionne jusqu'à un certain point, les résultats pouvant donner un aspect artificiel si poussée trop loin. Ce que vous souhaitez typiquement éviter est ceci (en utilisant le module _mappage de tonalités_, le curseur de contraste à son maximum) :

![Exemple d'image HDR](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-hdr-too-much.jpg)

Le module _filmique_ montre qu'une autre approche est possible et, généralement, donne des résultats plus naturels. Il considère chaque pixel individuellement, sans faire de distinction entre le contraste global et local. Si _filmique_ comprime trop le contraste, il est toujours possible de récupérer le contraste local avec l'excellent module _contraste local_ par exemple.

_filmique_ est fait pour être utilisé sans le module _courbe de base_ (activé par défaut dans darktable). La _courbe de base_ vient très tôt dans le flux de traitement et donne une image contrastée dans laquelle les hautes lumières sont souvent atténuées. Récupérer les détails perdus via la _courbe de base_ est difficile. D'autre part, simplement désactiver la courbe de base entraîne généralement des images pâles, manquant de contraste et de saturation. D'autres techniques d'amélioration du contraste doivent être utilisées pour compenser cela. _filmique_ vient plus tard que _courbe de base_ dans le flux de traitement, et donne plus de contrôle pour exploiter correctement la plage dynamique de l'image de sortie.

La première chose que fait _filmique_ est d'appliquer une courbe logarithmique sur l'image, de sorte que les « stops « (facteur de deux de luminance d'un espace linéaire) soient répartis uniformément sur l'histogramme.

La source d'inspiration derrière _filmique_ est le film analogique. Une différence entre le film analogique et les capteurs numériques est la manière dont ils réagissent à la surexposition. Les capteurs numériques ont un seuil d'écrêtage au-dessus duquel tout est considéré blanc : ils ne peuvent pas faire la distinction entre les pixels légèrement supérieurs au seuil et les pixels surexposés. Le film analogique réagit différemment : le contraste est réduit progressivement à mesure que l’image est surexposée, sans cet effet de seuil. Cela permet aux films analogiques de restituer une scène avec une plage dynamique élevée sur un support avec une plage dynamique inférieure, tout en maintenant le contraste dans les tons moyens.

Un effet similaire peut être obtenu dans le monde numérique en appliquant une _courbe  en S_ à l'image, tant que les hautes lumières ne sont pas écrêtées. Avec le module _courbe de tonalités_, on peut dessiner une courbe telle que celle-ci :

![Ajustement d'exposition](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-S-shaped.png)

La seconde chose que fait _filmique_ est d'appliquer une telle courbe, mais au lieu de fournir cette courbe manuellement, la courbe est automatiquement calculée depuis un ensemble de paramètres. Cela facilite l'équilibrage des ombres, hautes lumières et tons moyens.

### Exemple d'image

Traitons notre image avec ce module. Avant d'appliquer _filmique_, nous devons d'abord désactiver le module _courbe de base_, et ensuite ajuster l'_exposition_. Aucun pixel ne doit être surexposé ou sous-exposé. Dans notre situation, nous devons réduire l'exposition afin d'éviter de surexposer le ciel :

![Ajustement d'exposition](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-exposure-fr.png)

Afin que les paramètres automatiques fonctionnent de leur mieux, il est recommander d'utiliser le mode `AMaZe` du module _dématriçage_. Activer un module de _réduction de bruit_ avant _filmique_, dans le flux de traitement (ex : _réduction de bruit (profil)_), peut également aider.

### Forme logarithmique

La première chose affichée dans le module _filmique_ est un aperçu de la courbe appliquée à l'image. La courbe n'est pas directement éditable, l'objectif du module étant d'ajuster la courbe via les curseurs situés en dessous.

Afin d'obtenir un bon point de départ, _filmique_ fournit une pipette de réglage de `niveaux automatiques `. Par défaut, ce module considère l’ensemble de l’image et définit les trois curseurs ci-dessus en fonction de la luminance moyenne, de la zone la plus lumineuse et de la zone la plus sombre :

![One click on "auto tune levels"](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-autotune-levels-fr.png)

Le curseur noir est souvent erroné. Il n'est actuellement pas facile pour un outil automatique de sélectionner le bon niveau de noir (il ne peut pas prendre un noir absolu comme référence, puisqu'un noir absolu correspondrait à l'infini sur une échelle logarithmique). On peut résoudre cela en déterminant la plage dynamique de l’image (sur une image suffisamment contrastée, c’est la plage dynamique de la caméra, c’est-à-dire environ 14 EV sur un appareil haut de gamme ou environ 10 EV pour un appareil compact moyen). Le curseur noir peut être défini par la valeur du blanc moins la plage dynamique. Alternativement, on peut déplacer le curseur pour laisser l'histogramme remplir son axe horizontal. Dans notre cas, nous devons également ajuster le curseur blanc pour que le soleil soit complètement à droite de l'histogramme :

![Ajustement manuel des niveaux de noir et blanc](https://raw.githubusercontent.com/Nilvus/dtorg/master/content/blog/2018-12-25-darktable-2.6/filmic-adjust-white-black-fr.png)

Après ces paramètres, l'histogramme est étalé sur la plage dynamique de l'image cible. Aucun pixel n'est surexposé :

![Histogramme après ajustement](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-adjust-histogram.png)

C'est ici que la magie opère : la pipette de _luminance de gris moyen_ permet de choisir quelle partie de l'image sera considérée comme gris moyen (50% de luminance). Par exemple, si nous le définissons sur la joue du chien, nous obtenons ceci :

![Middle grey on the dog's cheek](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-dog.jpg)

Si nous sélectionnons le nez du chien, qui est plus foncé, nous obtenons une image plus claire :

![Middle grey on the dog's nose](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-nose.jpg)

D'autre part, si nous sélectionnons une zone claire du ciel, l'exposition globale est diminuée afin d'obtenir une exposition correcte du ciel :

![Middle grey on the sky](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-sky.jpg)

Sur toutes ces images, les points blancs et noirs sont conservés, ni sur ou sous-exposés. Au final, sélectionner l'herbe derrière le chien est probablement la meilleure option ici, mais c'est une question de goût :

![Middle grey on the grass](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-middle-grey-grass.jpg)

### _Courbe filmique en S_

Allons maintenant découvrir la seconde partie de ce module : la `courbe filmique en S`. Principalement, cette courbe va permettre d'augmenter le contraste dans les tons moyens (le curseur `contraste`) et comprimer les ombres et/ou hautes lumières. Peut-être ne l'avez-vous pas remarqué, mais le module _filmique_ a déjà initié cela à son activation, le curseur de `contraste` étant défini par défaut à 1.5. Si nous désactivons la `courbe filmique en S` (donc définir le `contraste` à 1), nous obtenons une image plus terne :

![No contrast in S-shaped curve](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-no-contrast.jpg)

D'autre part, nous pouvons ajouter plus de contraste que par défaut :

![High contrast in S-shaped curve](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-high-contrast.jpg)

Bien sûr, à un certain niveau, augmenter le contraste entraînera une perte d'informations dans les ombres et/ou hautes lumières,  La courbe en haut du module permet de voir quelle information est perdue : idéalement la courbe ne devrait pas toucher le bas ou le haut du cadre.
Par exemple, si vous obtenez la courbe ci-dessous, vous avez détruit vos ombres :

![Clipped shadows](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-curve-clipped-shadows.png)

Les curseurs sous `contraste` permettent d'affiner précisément la courbe :

* `latitude` donne la gamme de l'image correspondant aux tons moyens sur lesquels le contraste sera augmenté.

* `équilibre ombres-hautes lumières` définit la place à donner aux ombres ou aux hautes lumières.

* Le menu de contrôle `rendu` contrôle l'interpolation entre les points de la courbe. La valeur par défaut donne généralement de bons résultats, mais peut aussi être totalement fausse (par exemple, produire une courbe non monotone) lorsque vous poussez les paramètres à leur extrême. Essayez d'autres modes lorsque cela se produit.

L'augmentation du contraste produit souvent une augmentation de la saturation, et un écrêtage de gamme. Le curseur `saturation`permet de diminuer la saturation dans les ombres et hautes lumières afin d'éviter cela. D'autre part, dans les hautes lumières, darktable doit habituellement choisir entre la préservation de la luminance et de la chrominance. Par défaut, il préserve la luminance mais il est possible de privilégier la chrominance par le biais de la case à cocher correspondante.

Il existe une section masquée `destination/affichage`, peu utile pour la plupart des utilisateurs. Attendez-vous à des images horribles si vous l'utilisez sans lire le manuel et savoir ce que vous faites !

### Touche finale et contraste local

Le contraste a été comprimé dans le ciel, mais nous voyons toujours un peu de texture. Si nous voulons augmenter le contraste local du ciel, le module _contraste local_ avec un masque paramétrique sur la partie la plus claire de l'image produit ce résultat :

![Middle grey on the grass](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/filmic-and-local-contrast.jpg)

### Documentation complémentaire

Cette partie vous donne un aperçu de ce qui est possible avec le module _filmique_. Bien entendu, il est recommandé de lire la manuel de darktable pour plus de précisions.
Pour de plus amples informations (plus de détails techniques, comparaison avec d'autres techniques, exemples d'images réelles, ...), vous pouvez également lire l'article suivant (en anglais) : "[Filmic, darktable and the quest of the HDR tone mapping](https://eng.aurelienpierre.com/2018/11/30/filmic-darktable-and-the-quest-of-the-hdr-tone-mapping/)", par Aurélien Pierre, le créateur du module.

## Gestionnaire de clones dans la table noire

darktable vous permet de conserver plusieurs historiques différents de la même image. En cliquant sur le bouton `cloner` dans le module _images sélectionnées_ de la table lumineuse, cela donne un clone de l'image : le fichier RAW n'est pas copié, mais darktable conserve ainsi deux piles d'historique distinctes pour cette image.

darktable 2.6 facilite encore plus le travail avec des clones, grâce au nouveau module apparaissant dans le panneau gauche de la chambre noire :

![Gestionnaire de clones](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/dm-initial.png)

Première amélioration : de fait, le module étant dans la chambre noire, il est désormais possible de travailler avec les différents clones, sans quitter cette dernière.

Deuxième amélioration : un bref commentaire peut désormais être associé à chaque clone de l'image. Supposons que nous souhaitons comparer notre image développée via le module _filmique_ avec un développement fait via la fonction de `fusion d'exposition` du module _courbe de base_. Nous pouvons démarrer avec un ajustement d'exposition basique et conserver cette version pour des développements futurs :

![Gestionnaire de clones](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/dm-basic.png)

Ensuite, un clic sur le bouton `créer un clone avec le même historique` (![créer un clone](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/dm-create-duplicate.png)) donne un clone sur lequel nous pouvons appliquons notre traitement basé sur le module _filmique_ :

![Gestionnaire de clones](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/dm-filmic.png)

Afin d'obtenir une nouvelle version, nous sélectionnons d'abord le premier par un double-clic avant de créer un clone :

![Gestionnaire de clones](https://raw.githubusercontent.com/moy/dtorg/a925974d80d6d088d2007c8955328d7860b29128/content/blog/2018-12-25-darktable-2.6/dm-fusion.png)

Pour comparer les clones, un simple clic prolongé sur un autre montre cette version de l'image à un niveau de zoom ajusté à l'écran. Il vous faudra maintenir le clic jusqu'à ce que l'image soit affichée complètement la première fois. L'opération sera immédiate par la suite, vous permettant de cliquer et relâcher plusieurs fois afin d'obtenir une comparaison avant/après instantanée.

Notez bien que les miniatures de l'image sont seulement mises à jour lorsque vous quittez l'image. La miniature de l'image tout juste éditée n'est donc, en général, pas à jour.

## Refonte du module _balance couleur_

_balance couleur_ a été considérablement amélioré.
Although its name contains "color", it is actually a much more general module. It can adjust levels pretty much like the "levels" module, and can now also tweak the contrast with an S-shaped curve. Obviously, you can also still adjust the colors to add or remove a color cast in the shadows, highlight and midtones separately.

The module gains two modes to work in ProPhotoRGB mode. Also, you now have the choice between the old RGBL (Red, Green, Blue, Luma) sliders, and HSL (Hue, Saturation, Luma).

Let's play with the module on an image with multiple white balances. This is the original image, with only the basic modules activated, and base curve disabled:

![ ](https://raw.githubusercontent.com/darktable-org/dtorg/8d648990980a056872fb7dd74d7bec748b4f831a/content/blog/2018-12-25-darktable-2.6/cb-active-modules.jpg)

The snow is obviously white in the real scene, but the snow exposed to the sun reflects the sun's light, while the one in the shadow reflects the sky's light, much bluer. The color picker module in the right sidebar of the darkroom allows visualizing and quantifying these color casts:

![ ](https://raw.githubusercontent.com/darktable-org/dtorg/8d648990980a056872fb7dd74d7bec748b4f831a/content/blog/2018-12-25-darktable-2.6/cb-patches-original.png)

(The negative value for the 'b' channel represents the blue color)

The "color balance" module now has color pickers to neutralize the colors. On this image, the global optimizer works rather well. After one click on "neutralize colors", the blue cast in the shadows is reduced:

![ ](https://raw.githubusercontent.com/darktable-org/dtorg/8d648990980a056872fb7dd74d7bec748b4f831a/content/blog/2018-12-25-darktable-2.6/cb-picker-neutralize.jpg)

Looking more carefully at the patches selected by the picker, notice that the 'b' value is now much closer to 0:

![ ](https://raw.githubusercontent.com/darktable-org/dtorg/8d648990980a056872fb7dd74d7bec748b4f831a/content/blog/2018-12-25-darktable-2.6/cb-patches-neutralized.png)

If the global optimizer guesses wrong, it is possible to specify color patches for highlights, shadows and mid-tones (preferably in this order) separately with the corresponding color pickers, and if needed re-launch the "neutralize colors" (called "neutralize colors from patches" once you have selected these patches).

Similarly, the tones can be adjusted similarly to the "levels" module, either with the global "optimize luma" or with individual pickers.
The "master" section at the top allows adjusting the global contrast and saturation. "contrast fulcrum" and "contrast" apply an S-shaped curve, centered around the fulcrum, and with a slope given by the contrast. In other words, with a positive contrast, parts of the image below the fulcrum will be darkened and parts above it will have their
luminance increased:

![ ](https://raw.githubusercontent.com/darktable-org/dtorg/8d648990980a056872fb7dd74d7bec748b4f831a/content/blog/2018-12-25-darktable-2.6/cb-contrast.jpg)

## Floutage par détection de bords des masques de fusion

La fonction de fusion de darktable permet de sélectionner une partie de l'image, appelée un masque, afin d'appliquer la transformation apportée par le module sur cette partie. Après création du masque (dessiné ou paramétrique), il est possible d'adoucir les bords du masque avec un effet de floutage.

darktable 2.6 donne plus de contrôle sur la manière dont le floutage du masque est rendu. Afin d'en comprendre le fonctionnement, regardons les deux principales méthodes de floutage. La plus commune est le flou gaussien, et donne en gros le même effet qu'une photo avec une mise au point incorrecte. En flou gaussien, la valeur (luminance et chrominance) de chaque pixel est diffusée uniformément aux pixels environnants. L'effet de diffusion s'atténue à mesure qu'on s'éloigne du pixel de départ. Dans darktable, le flou gaussien est disponible dans le module _filtre passe-bas_ :

![Copie sur l'image résiduelle](https://raw.githubusercontent.com/Nilvus/dtorg/3e455aa26cec00f41f386ec2fd3d68a6cad3c821/content/blog/2018-12-25-darktable-2.6/gaussian-blur-fr.png)

Un autre type de floutage se base sur le [_filtre bilatéral_ (article en anglais)](https://en.wikipedia.org/wiki/Bilateral_filter), parfois appelé flou de surface (en raison du nom de l'outil correspondant dans Photoshop), ou floutage par détection de bord. Dans ce mode, la valeur de chaque pixel est étendue aux pixels environnants, mais l'influence d'un pixel est réduite quand les pixels ont des valeurs différentes. Par exemple :

![Copie sur l'image résiduelle](https://raw.githubusercontent.com/Nilvus/dtorg/b3118285ba128ef422d5b0e6b3f08a589efdf73a/content/blog/2018-12-25-darktable-2.6/edge-aware-blur-fr.png)

Un algorithme de floutage similaire peut être appliqué au masque, mais cette fois le masque est flouté et l'image résultante sert de guide pour le floutage. Ceci permet de définir grossièrement le masque et de l'affiner ensuite précisément avec les curseurs.

Supposons que nous souhaitions améliorer la couleur du ciel. Dans le module _zones de couleurs_, nous pouvons sélectionner le ciel avec un masque dessiné :

![Masque dessiné](https://raw.githubusercontent.com/Nilvus/dtorg/b3118285ba128ef422d5b0e6b3f08a589efdf73a/content/blog/2018-12-25-darktable-2.6/gb-mask-fr.png)

Évidemment, le résultat est pire avec un flou gaussien sur ce masque (le seul qui était disponible dans darktable 2.4) :

![Masque dessiné](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-mask-gauss-fr.png)

Cependant, en poussant le curseur du `rayon adoucissement`, le masque s'ajuste automatiquement au ciel, sans propagation aux montagnes. L'adoucissement réduit un peu l'opacité du masque. Cela peut être compensé avec le curseur d'`opacité du masque`. Et voilà :

![Masque dessiné](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-mask-feather-fr.png)

Notez qu'en poussant les curseurs de `rayon adoucissement` et `opacité du masque`, cela vous donne un outil similaire à l'_outil de sélection contiguë_ de GIMP,  souvent demandé par les utilisateurs de darktable : sélectionnez quelques pixels dans une zone et laissez l'outil sélectionner les pixels similaires environnants.

Par exemple, via un coup de pinceau à l'intérieur de la maison :

![Pinceau, sans adoucissement](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-brush-nofeather-fr.png)

Et maintenant en augmentant l'adoucissement :

![Pinceau, avec adoucissement](https://raw.githubusercontent.com/Nilvus/dtorg/3654bb506b012e1b738c5b0ff9a553b5fce7cecb/content/blog/2018-12-25-darktable-2.6/gb-brush-feather-fr.png)

# Améliorations de la table lumineuse et de la table

* La recherche d'un lieu depuis la vue _carte_ a été corrigé :

![Recherche d'un lieu depuis la vue _carte_](https://raw.githubusercontent.com/darktable-org/dtorg/13bfb297e6364764110daba34d9080347b581733/content/blog/2018-12-25-darktable-2.6/map-search.png)

* L'aspect de la table lumineuse a été amélioré. Le texte de fond de l'image était souvent illisible car masqué par l'image. L'état de la copie locale est désormais affiché dans l'angle haut droit.

* On peut maintenant trier les images par rapport à l'`aspect` (éventuellement après un recadrage dans darktable) :

![Sort by aspect ratio](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-sort-by-fr.png)

* Il est aussi possible de spécifier l'ordre manuellement, en sélectionnant _tri personnalisé_ puis par un glisser-déposer des images afin de les réordonner :

![Tri personnalisé](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-custom-sort-fr.png)

* Les collections peuvent maintenant être filtrées par _aspect_, _exposition_ et _copie locale_ :

![Filtres de collection](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-collection-filters-fr.png)

* En sélectionnant un filtre dans _filtres de collection_, le nombre d'images correspondant à chaque filtre est affiché. Dans l'exemple ci-dessous, 12 images ont été prises à une vitesse d'1/2000" et 6 à 1/1600" :

![Nombre d'images par collection](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/lt-collection-nb-fr.png)

2. amélioration visuelle de la table lumineuse, code couleur, type image, état de copie locale, possibilité d'afficher des informations directement sur la miniature
3. possibilité d'avoir des ascenseurs sur la table lumineuse ou sur la table lumineuse et la chambre noire
11. amélioration du support de turboprint (choix du type de papier, dialogue turboprint complet affiché avant impression) 
30. meilleur support des groupes (étoiles, notes sur toutes les photos regroupées)
31. ajout d'un tri par groupe de photo
28. différents types de sélection pour les tags hiérarchiques dans le module collection

# Autres fonctionnalités importantes

## Contrôle plus fin sur le bruit pour les modules _réduction du bruit (profil)_ et _réduction du bruit RAW_

New curves have been introduced to give finer control for the "wavelet" mode of profiled denoise as well as the raw denoise module.
These curves allow controlling the force of denoising frequency by frequency.
In other words, you can adapt the force of the denoising to the noise coarseness.
The "all" curve allow to change the force for all channels at the same time, while "R", "G" and "B" curves allow changing the force separately for red, green, and blue channels.
It was already possible to denoise red, green and blue channels selectively using the "RGB red/green/blue channel" blend modes, but the new module can do this with a single instance and no blending.

Let's see an example of what can be done with the "all" curves first.
First, zoom into the image to be at a 100% zoom level.
At smaller zoom levels the result is an approximation, which is not always accurate.
Let's activate the denoise profiled, in wavelet mode.
A force between 0.150 and 0.3 is usually a good starting point.
Here, to better see the influence of the curve, we use a force of 0.5.

Here is the image we obtain with a flat curve:

![Boat denoised using a flat curve](https://raw.githubusercontent.com/moy/dtorg/27e2db03af22d334d9a529081180ab25af3224f6/content/blog/2018-12-25-darktable-2.6/wavelets_flat.png)

Now, by lowering the force on a specific frequency, we can obtain very different results.
Here is what we obtain when lowering the force on a quite coarse frequency:
![Boat denoised with less reduction on the central frequency](https://raw.githubusercontent.com/moy/dtorg/27e2db03af22d334d9a529081180ab25af3224f6/content/blog/2018-12-25-darktable-2.6/wavelets_coarse_noise.png)

The result is not pleasing to the eyes because coarse grain noise are very disturbing.
Here, we reduced the denoising force too much.

Let's try the same test on the finest frequency:
![Boat denoised with less reduction on the finest frequency](https://raw.githubusercontent.com/moy/dtorg/27e2db03af22d334d9a529081180ab25af3224f6/content/blog/2018-12-25-darktable-2.6/wavelets_details.png)
Here, we obtain an image which is much less disturbing than the last one: the fine grain noise is less distrurbing than the coarse grain one.
This image is even arguably more natural than the one with a flat curve.

By playing with the different frequencies, on can get better trade-offs between smoothing and detail preservation.

In addition, new presets are now available for the *denoise (profiled)* module that exploits this curve:

* one for chroma noise (false colors), where the denoising is increased for fine details, as the color should not change much from one pixel to another.

* one for luma noise (false luminance), where the denoising is reduced on finest details and some coarse scales. It aims at providing a nice trade-off between noise and smoothing for pictures that are not too noisy (forget about extended ISO values for instance. For such pictures we have to use less automatic strategies).

The chroma preset should be used on the first instance, and the luma preset on the second instance.

For images that are more complicated, or if you want to get an even better trade-off, you can use the RGB curves.
Indeed, the sensors usually capture R, G, and B values.
Depending on the lighting on the scene, the channels can exhibit different noise characteristics:

* one of the channel may be more (or even much more) noisy than the other

* one channel may have coarser noise than another

You can try to get a better denoising trade-off by denoising the channels separately, using the RGB curves and an instance of channel mixer used to visualize the channels:
![Denoising the red channel](https://raw.githubusercontent.com/moy/dtorg/27e2db03af22d334d9a529081180ab25af3224f6/content/blog/2018-12-25-darktable-2.6/wavelets_red.png)
Once RGB channels have been denoised, you can use another instance in color blend mode to remove remaining color problems.

Note that denoising RGB channels individually should be done *before* using an instance in color blend mode, as doing this will mix the channels and change the characteristics of noise.

These explanations were all using the *denoise (profiled)* module as an
example, but you can follow the same steps with the *raw denoise* module.
Also note that the tip of denoising RGB channels separately while visualizing the channels using the channel mixer is also useful to set the parameters of the *denoise bilateral* module.

## Un nouveau mode _logarithmique_ pour le module _correction du profil d'entrée_

Similarly to the logarithmic shaper in the *filmic* module, the *unbreak input profile* module is now equiped with a logarithmic mode, with the same sliders and pickers. The difference is that *unbreak input profile* comes before the application of the input profile, while *filmic* comes later in the pipeline.

Using the log mode of *unbreak input profile* usually results in a pale image, lacking contrast. For example, on the [Mairi Troisieme](https://discuss.pixls.us/t/playraw-mairi-troisieme/967) image, we may get this:

![Pale image after unbreak input profile](https://raw.githubusercontent.com/darktable-org/dtorg/13bfb297e6364764110daba34d9080347b581733/content/blog/2018-12-25-darktable-2.6/unbreak-fade.jpg)

Getting a fade image is indeed the point: the logarithmic mode in *unbreak input profile* is meant to be used in conjunction with another module later in the pipeline to give more pep to the image (for example the color *balance module*, especially with the new features in this version). The advantage of this flow is that most of the pipeline, in particular the application of the input color profile, is done on an image that fills in the histogram properly, and without extreme values. In other words, we distinguish a technical part of the edit and an artistic part. Back to our image, the colorbalance allows for example this:

![Vivid image after color balance](https://raw.githubusercontent.com/darktable-org/dtorg/13bfb297e6364764110daba34d9080347b581733/content/blog/2018-12-25-darktable-2.6/unbreak-colorbalanced.jpg)

Note that in this workflow, it is mandatory to work in the same order as the pipeline does: trying to adjust the settings of *unbreak input profile* after tuning the levels and contrast with *color balance* is doomed to failure.

In practice, the *filmic* module can do more or less the same, but has the advantage of having everything in a single module for a quicker edit.

## Possibilité d'ajuster l'opacité de chaque correction du module _correction de tâches_

Le module _correction de tâches_ bénéficie de certaines des fonctionnalités intéressantes du module _retouche_. Par exemple, il est désormais possible de définir l'opacité des formes individuellement (`Contrôle`+`clic`).

## Amélioration du support des fichiers RAW monochromes

While it is possible to turn any RAW image into monochrome, some cameras have no color filters in front of their sensors, and produce monochrome RAW files. Previous versions of darktable allowed disabling the *demosaic* module for monochrome RAW. This version improves the treatment of these images further by disabling chromatic aberration correction, turn of the *white balance* module (if only to avoid spurious error messages), and re-enable normal processing such as auto-exposure which was disabled in previous versions.

## Amélioration du support des instances multiples de modules

### Possibilité de renommer les instances de module

When using multiple instances of the same module for different purposes, it is often hard to remember which instance serves which purpose. darktable now allows giving a name to each instance to simplify this.
For example, if you use two instances of denoise profile, one for chrominance noise, and one for luminance noise, you may set the name of the first one as "chroma", and the name of the second one as "luma".
The steps for setting the name of the chroma instance are described bellow:
* first, click on the "multiple instance action" button
* click on "rename"
* enter the name
* press "enter" on your keyboard

![Renaming an instance](https://raw.githubusercontent.com/darktable-org/dtorg/e2c7cca8dc4fdfa9b3872f1a6c5322b1790cfffa/content/blog/2018-12-25-darktable-2.6/rename.png)

### Amélioration du couper/coller

TODO

### Appliquer un style en un clic à une nouvelle instance

TODO

## Recadrage préservant le ratio dans le module _correction de perspective_

Le module _correction de perspective_ permet désormais un recadrage semi-automatique préservant le format original de l'image :

![Recadrage automatique depuis le format original](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/pc-original-format-fr.png)

Glissez simplement la souris sur l'image pour sélectionner la portion à recadrer :

![Recadrer une image](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/pc-crop-image.jpg)

L'aire est ajustée automatiquement afin d'éviter d'inclure des parties noires de l'image cible. Ceci évite d'avoir à passer au module _recadrer et pivoter_.

# Améliorations d'utilisation

## Aide contextuelle

darktable est une bête complexe à maîtriser, et lire le manuel pour la fonctionnalité que vous essayez d'utiliser est souvent une bonne idée, même si vous avez déjà lu le manuel complet. Cette version introduit une aide contextuelle pour aider les utilisateurs : un bouton `?`est disponible en haut à droite de l'interface, à côté du bouton `préférences`:

![Aide contextuelle](https://raw.githubusercontent.com/darktable-org/dtorg/e2c7cca8dc4fdfa9b3872f1a6c5322b1790cfffa/content/blog/2018-12-25-darktable-2.6/contextual-help.png)

Après avoir cliqué, le curseur de la souris se transforme en un point d'interrogation lorsqu'il survole tout élément de l'interface ayant une aide disponible :

![Aide contextuelle activée](https://raw.githubusercontent.com/darktable-org/dtorg/e2c7cca8dc4fdfa9b3872f1a6c5322b1790cfffa/content/blog/2018-12-25-darktable-2.6/contextual-help-active.png)

En cliquant ensuite sur l'élément, votre navigateur web va s'ouvrir sur la section correspondante de la documentation darktable.

## Organisation des modules en onglets

La répartition des modules en groupes ou en onglets (_modules de base_, _modules de tonalité_, _modules de couleur_, _modules d'améliorations_ et _groupe d'effets_) est maintenant personnalisable. La distribution originale dans darktable suit une catégorisation thématique, mais certains utilisateurs préfèrent le regroupement par étapes du flux de travail.
Par exemple, le module _dématriçage_ est actuellement classé dans le groupe _modules de couleur_ parce qu'il traite les couleurs, mais il intervient très tôt dans le flux de traitement ce qui peut avoir une incidence sur presque tous les autres modules. Il est donc judicieux de le classer dans le groupe de base.

Une nouvelle catégorisation a été proposée, mais les discussions entre les développeurs n’ont pas permis de parvenir à un consensus, car la modification des groupes risque de perturber les anciens utilisateurs habitués à la présentation originale.

Dans darktable 2.6, le compromis trouvé a été de permettre une disposition personnalisée.

Vous pouvez modifier cette disposition manuellement en éditant le fichier `.config/darktable/darktablerc`, ou utiliser l'un des scripts fournis dans la distribution source de darktable : `tools/iop-layout.sh` afin d'adopter une nouvelle disposition, et `tools/iop-layout-legacy.sh` pour revenir à celle d'origine.

Éditez ces scripts si vous souhaitez créer votre disposition personnelle. Ces scripts sont fait pour des utilisateurs avancés qui savent comment en exécuter un. Il n'est pas garanti qu'ils fonctionnent sous Windows. Si un consensus se dégage sur la meilleure présentation possible, celle-ci pourra être adoptée dans les futures versions de darktable afin que tous les utilisateurs puissent en bénéficier.

## Import depuis d'autres logiciels

* L'importation depuis Adobe Lightroom a été amélioré (les métadonnées « créateur », « droits », « titre » et « description » sont copiées de Lightroom vers darktable).
* Un nouveau script est fourni pour importer les collections depuis Capture One Pro (`tools/migrate_capture_one_pro.sql` dans le code source de darktable).

## Module _Courbe des tonalités_

L'interface utilisateur du module _courbe des tonalités_ a été améliorée de plusieurs façons. Premièrement, vous pouvez désormais utiliser une échelle logarithmique sur l'axe X ou l'axe Y, ou sur les deux :

![Échelle log-log sur la courbe des tonalités](https://raw.githubusercontent.com/moy/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-loglog.png)

Ceci facilite la manipulation des points proches de 0, i.e. affiner plus finement la partie de la courbe affectant les ombres.

Il est également possible de choisir l'algorithme utilisé pour l'interpolation, c'est-à-dire pour calculer la courbe elle-même en fonction des points de contrôle édités par l'utilisateur. Il y avait déjà plusieurs algorithmes disponibles, mais masqués à l'utilisateur. Par exemple, sélectionner le paramètre prédéfini `contraste - haut (linéaire)` sélectionnait une spline cubique pour vous. Pour les courbes très lisses, l’algorithme d’interpolation ne modifie pas beaucoup le résultat, mais pour les courbes utilisant des points proches les uns des autres, il peut provoquer des modifications importantes.

Par exemple, regardons le même ensemble de points de contrôle à différentes interpolations. `spline cubique` donne une courbe très lisse, mais peut donner un résultat non monotone, c'est-à-dire une inversion de contraste sur l'image résultante :

![spline cubique](https://raw.githubusercontent.com/moy/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-cubic.png)

`spline centripète` réduit le potentiel d'image non-monotone :

![spline centripète](https://raw.githubusercontent.com/moy/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-centripetal.png)

`spline monotone`, utilisé par défaut, peut être moins lisse mais évite de fait la non-monotonie :

![spline monotone](https://raw.githubusercontent.com/moy/dtorg/master/content/blog/2018-12-25-darktable-2.6/tone-curve-monotonic.png)

## Autres améliorations

* Plus d'éléments sont personnalisables via CSS. En particulier, certains qui étaient codés en dur avec un avant-plan clair et un arrière-plan sombre, ce qui rendait impossible d'avoir un thème à l'arrière-plan clair.

* Les niveaux de zoom 50%, 400%, 800% et 1600% sont disponibles dans la chambre noire. Alors que la plupart des opérations fournies par darktable ont pour objectif d'améliorer les couleurs et la tonalité de l'image globale, il est parfois intéressant d’obtenir une vue précise au niveau des pixels sur une petite partie de l’image. Le facteur de zoom les plus élevé précédemment disponible (200%) n'était pas toujours suffisant, spécialement sur des écrans à haute résolution. Notez que ces niveaux de zoom sont accessibles dans le menu de la zone d'aperçu, mais pas avec la molette de la souris.

![Niveau de zoom 1600%](https://raw.githubusercontent.com/Nilvus/dtorg/2f031849b7818b775cee0151502daa2ad16f6195/content/blog/2018-12-25-darktable-2.6/zoom-1600-fr.png)

* Tous les masques sont prévisualisés et peuvent être ajustés avant d'être dessinés. Ceci s'applique également aux formes du module _liquéfier_.

* Le fonctionnement de la pipette de couleur a été retravaillé. Par exemple, la pipette du module _exposition_ n'était pas désactivé lorsque le module l'était. Corriger cela est devenu plus important avec de plus en plus de modules utilisant la pipette (_filmique_, _correction du profil d'entrée_, _balance couleur_).
